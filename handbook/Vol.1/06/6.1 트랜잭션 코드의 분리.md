
## AOP
* AOP는 IoC/DI, 서비스 추상화와 더불어 Spring의 3대 기반 기술 중 하나이다.
* AOP를 이해하기 위해서는?
  * OOP를 대체하려고 하는 것처럼 보이는데.. 등장배경과 Spring이 이것을 도입한 이유, AOP 적용을 통해 얻은 장점을 이해해야 한다.
* Spring에서 적용된 가장 인기 있는 AOP 적용 대상은 바로 `선언적 트랜잭션` 기능이다.

### 6.1.1 메소드 분리
* Spring이 제공하는 트랜잭션 인터페이스를 사용했음에도 불구하고 비즈니스 로직이 있어야할 메소드안에 트랜잭션 코드가 많이 존재하고 있다.
* 트랜잭션의 경계를 비즈니스 전후에 설정하는 것이 논리적으로 맞기 때문에 Service 메소드안에 두었던 것을 옮기도록 한다

```java
public void upgradeLevels() throws Exception {
  TransactionStatus transactionStatus = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
  try {
    List<User> users = userDao.getAll();
    for(User user: users) {
      if (canUpgradeLevel(user)) {
        userDao.update(user);
        upgradeLevel(user);
      }
      this.transactionManager.commit(transactionStatus)
        
    }
  } catch(Exception e) {
    this.transactionManager.rollback(status);
    log.error("upgrade level error", e);
  }
}

private boolean canUpgradeLevel(User user) {
  Boolean changed = null;
  if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
      user.setLevel(Level.SILVER);
      changed = true;
  } else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
      user.setLevel(Level.GOLD);
      changed = true;
  } else if(user.getLevel() == Level.GOLD) {
      changed = false;
  } else {
      changed = false;
  }
  return changed;
}
```
* 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치한다.
* 위 코드의 특징 :트랜잭션 경계설정 로직과 비즈니스 로직 간에 주고받는 정보가 없다.
* 다음과 같이 성격이 다른 코드를 두개의 메소드로 분리한다

```java
public void upgradeLevels() throws Exception {
  TransactionStatus transactionStatus = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
  try {
    List<User> users = userDao.getAll();
    for(User user: users) {
      if (canUpgradeLevel(user)) {
        upgradeLevel(user);
      }
      this.transactionManager.commit(transactionStatus)
        
    }
  } catch(Exception e) {
    this.transactionManager.rollback(status);
    log.error("upgrade level error", e);
  }
}

private void upgradeLevelsInternal() {
  List<User> users = userDao.getAll();
  for(User user: users) {
    if (canUpgradeLevel(user)) {
      upgradeLevel(user);
    }
  }
}
```
* 리팩토링을 한 이후에는 순수하게 사용자 레벨 업그레이드를 담당하는 비즈니스 로직 코드만 독립적인 메소드에 담겨 있어 이해하기도 편하고 수정하기에도 부담이 적어졌다.
