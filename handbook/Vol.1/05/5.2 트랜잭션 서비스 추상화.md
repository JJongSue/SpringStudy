# 5장 - 서비스 추상화

## 5.2. 트랜잭션 서비스 추상화
* 작업 중 장애발생하면 처리중이였던 작업은 모두 롤백하기로 결정

### 5.2.1 모 아니면 도
* 테스트 시나리오 중 DB서버를 다운 시키거나 네트워크를 끊을 수는 없다.
* 장애가 발생했을 때 일어나는 예외가 던져지는 상황을 의도적으로 만들어본다.
* 테스트용 UserService 대역
  * 테스트용으로 특별히 만든 UserService의 대역을 사용한다. (UserService.java)
  * 테스트 클래스 안에 내부클래스로 UserService를 상속해서 만들도록 한다.
  ```java
  static class TestUserService extends UserService {
		private String id;
		
		private TestUserService(String id) {
			this.id = id;
		}
		
		protected void upgradeLevel(User user) {
			if(user.getId().equals(this.id)) {
				throw new TestUserServiceException();
			}
			super.upgradeLevel(user);
		}
		
		static class TestUserServiceException extends RuntimeException {
			
		}
	}
  ```
  * UserServiceTest.java
  ```java
  @Test
	public void upgradeAllOrNothing() {
		UserService testUserService = new TestUserService(users.get(3).getId()); // 예외를 발생시킬 네 번째 사용자의 id를 넣어서 생성한다.
		testUserService.setUserDao(this.userDao); // userDao 수동 DI
		
		userDao.deleteAll();
		for(User user : users) {
			userDao.add(user);
		}
		
		try {
			// testUserService 는 업그레이드 작업 중에 예외가 발생해야 한다. 정상 종료라면 문제가 있으니 실패
			testUserService.upgradeLevels();
			fail("TestUserServiceException excepted");
		} catch(TestUserServiceException e) { // TestUserService가 던져주는 예외를 잡아서 계속 진행되도록 한다. 그 외의 예외라면 테스트 실패
			
		}
		// 예외가 발생하기 전에 레벨 변경이 있었던 사용자의 레벨이 처음 상태로 변경되었는지 확인
		checkLevelUpgraded(users.get(1), false);
	}
  ```

* TEST는 실패한다.
* 바로 트렌젝션 문제이다.
  * upgradeLevels() 메소드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.
   
### 5.2.2 트랜잭션 경계 설정
* 모든 트랜잭션은 시작점과 끝점이 있다.
* 시작하는 방법은 한 가지이지만 끝나는 방법은 두 가지(롤백과 커밋) 이다.
* 트랜잭션의 경계 : 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 말한다.

* JDBC 트랜잭션의 트랜잭션 경계 설정
  * 하나의 Connection을 사용하다가 닫는 사이에서 일어난다.
  * setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 트랜잭션의 경계설정 이라고 한다.
* UserService와 UserDao의 트랜잭션 문제
  * 코드 어디에도 트랜잭션 경계설정 코드가 존재하지 않기 때문에 트랜잭션이 적용되지 않았다.
  * 여러 쿼리들이 하나의 트랜잭션으로 묶이려면? DB커넥션 하나에서 실행되야 한다.
* 비즈니스 로직 내 트랜잭션 경계설정
  * 트랜잭션 경계를 upgradeLevels()메서드 안에 두려면 DB커넥션도 이 메서드 안에서 만들고 종료시킬 필요가 있다.
