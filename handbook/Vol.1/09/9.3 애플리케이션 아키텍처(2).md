# 9.3 애플리케이션 아키텍처

# 9.3.3 오브젝트 중심 아키텍처

## 빈약한 도메인 오브젝트 방식

- 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 기능을 가지고 있지 않으면 → 빈약한(anemic) 오브젝트

- 빈약한 도메인 오브젝트 방식 구조(그림9-20 p806)

![https://user-images.githubusercontent.com/34182908/196029677-ee301c6a-cdf4-4cb6-bcbe-c01dc747213c.png](https://user-images.githubusercontent.com/34182908/196029677-ee301c6a-cdf4-4cb6-bcbe-c01dc747213c.png)

- 도메인 오브젝트는 3개의 계층에는 독립적으로 존재, 일관된 구조의 정보를 담아 계층 간에 전달하는데 사용
- 한계 : 거대 서비스 계층 방식과 유사
    - SQL에 의존적인 데이터 방식보다는 유연, 간결하지만, 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 **로직의 재사용성**이 떨어지고, **중복**의 문제가 발생하기 쉽다.
- 비즈니스 로직이 복잡하지 않다면, 가장 만들기 쉽고 3계층의 구조의 특징을 잘 살려서 개발할 수 있는 유용한 아키텍처

## 풍성한 도메인 오브젝트 방식(rich domain object)

- 또는 영리한 도메인 오브젝트(smart domain object)
- 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선된 것
- 어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있을 때, 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것

```java
public class Category {
	...
	List<Product> products;

	public int calcTotalOfProductPrice() {
		int sum = 0;
		for(Product product : this.products()) {
			sum += product.getPrice();
		}
		return sum;
	}
}
```

- 위와 같이 도메인 오브젝트에 로직을 담아두면 서비스 계층의 메소들에 따로 만드는 것보다 응집도가 높다.
- 만약 서비스 메소드에 담아져 있으면, 서비스도 DI 해줘야하고, 해당 서비스에 메소드가 있는지 모르는 개발자는 같은 기능을 가진 코드를 새로 작성할 수 도 있다.

```java
public class InventoryService {
	private CategoryService categoryService;
	
	public void setCategoryService(CategoryService categoryService) {
		this.categoryService = categoryService;
	}

	public void complecInventoryAnalysis() {
		...
		int total = this.categoryService.calcTotalOfProductPrice(category); 
		// -> 계산 로직에서 사용될 정보를 가진 Category를 파라미터로 전달해야 한다.
		...
	}
}
```

```java
public class InventoryService {
	public void complecInventoryAnalysis() {
		...
		int total = category.calcTotalOfProductPrice(); 
		// -> 서비스 계층의 메소드를 사용하는 코드보다 훨씬 간결, 직관적이라서 이해하기도 쉽다.
		// 무엇보다도 객체지향적이다.
		...
	}
}
```

- 풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식과 비슷하지만, 코드를 살펴보면 훨씬 간결, 객체지향적이다.
- 도메인 모델의 정보를 정적인 구조뿐 아니라 동적인 동작 방식에도 적극 활용할 수 있다.
- 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 서비스 오브젝트에 두는 것이 적당
- 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근x → 서비스 계층이 필요하기도 하다.(비즈니스 로직을 처리하는 중 DB에 담긴 정보를 가져와 활용하거나 결과를 다시 DB나 외부 시스템에 전송하는 등의 작업이 필요)
- 왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까?
    - 도메인 오브젝트는 스프링 컨테이너가 관리하는 오브젝트, 빈이 아니기 때문
    - 서비스 계층의 오브젝트, 데이터 액세스 계층의 오브젝트는 모두 스프링의 빈으로 등록되기 때문에 필요에 따라 서로 DI 가능
    - 도메인 오브젝트는 애플리케이션의 코드, 기타 프레임워크나 라이브러리, JDBC 템플릿 등에 의해 필요에 따라 새롭게 만들어지므로 스프링이 생성하거나 관리하는 오브젝트 X → DI를 받을 수 없다.
- 서비스 계층 : 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB에 반영하는 등의 작업과 함계 도메인 오브젝트가 갖고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리

![https://user-images.githubusercontent.com/34182908/196029854-4470d089-acc4-4a95-a3aa-a4915034c939.png](https://user-images.githubusercontent.com/34182908/196029854-4470d089-acc4-4a95-a3aa-a4915034c939.png)

그림 9-21  풍성한 도메인 오브젝트 방식 p810로

## 도메인 계층 방식

- 지금까지 살펴본 바로는 도메인 모델을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다.
    - 도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 엑세스 계층에서 가져온 내부 데이터를 분석하거나, 조건에 따라 오브젝트 정보를 변경, 생성하는 정도로 그치 수밖에 없다.
    - 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업 필요

- 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식
    - 도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해가져 올 수 있고, 생성 변경시 직접 DAO에게 변경사항을 반영해달라고 요청할 수는 없을까?
    - DAO외에도 다양한 기반계층의 서비스를 이용하도록 할 방법은 없을까?
    - 만약 도메인 오브젝트가 기존 3계층의 오브젝트를 DI 받아서 직접 이용할 수 있게 된다면 어떤일이 일어날까?
- 두 가지 특징
1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행
2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것

- 도메인 계층의 도메인 오브젝트들이 다른 오브젝트를 이용하는 방법 : DI
    - AspectJ AOP를 사용하여 도메인 오브젝트가 생성되는 시점에 DI 하도록 적용
- 도메인 계층 방식은 이전보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다.

- 서비스 계층을 사용해야하는 경우
    - 여러 도메인 오비젝트의 기능을 조합해서 복잡한 작업을 진행해야하는 경우
    - 굳이 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 가져와 클라이언트에 제공해야하는 경우(인터페이스 역할 담당)
    - 트랜잭션 경계를 설정하거나 특정 도메인 로직을 포함되지는 않지만 애플리케이션에서 필요로 하는 기반서비스를 이용해야 하는 작업
- 서비스 계층의 비중과 규모는 이전에 비해 훨씬 작다.
- 복잡하지 않은 애플리케이션에서는 서비스 계층을 제거하고, 모든 비즈니스 로직을 도메인 오브젝트에 담음 → 이 때 트랜잭션 경계가 프레젠테이션 계층에서 최초로 호출되는 도메인 오브젝트의 메소드에 설정

- 도메인 오브젝트를 독립적인 계층으로 만들려고 할때 고려해야할 중요 사항 : 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 여부)
1. 여전히 모든 계층에서 도메인 오브젝트를 사용
- 도메인 계층, 서비스 계층, 프레젠테이션 계층, 화면 출력을 위한 뷰에서도 사용할 수 있게하는 것
- 가장 손쉽고 편한 방법
- 주의하지 않으면 혼란을 심각한 혼란을 초래
    - 도메인 오브젝트의 메소드는 단순 값 조작이나 분석, 변환이 아니라 중요한 도메인/비즈니스 로직 담당
    - DB나 백엔드 시스템에 작업 결과를 반영할 수도 있다.
    - 이를 프레젠테이션 계층이나 뷰 등에서 사용하게 해주면 이를 함부로 사용하는 위험이 뒤따를 수 있다.
- 위의 방식을 피하는 방법
    - 가장 간단한 방식은 철저한 개발 가이드인을 만들고 이를 강력하게 적용
    - 이를 어기는 개발자가 있을 수 있기 때문에 코딩 정책의 적용을 분석할 수 있는 툴을 통해 검증하거나 AspectJ의 정책/표준 강제화 기능(policy/standards enforcement)기능을 사용

1. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것
- 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트(DTO)에 복사해서 넘겨준다
- DTO(Data Transfer Object)
    - 상태의 변화 허용x, 읽기 전용으로 만들어지기도 한다.
    - 반대로 사용자가 등록한 값이나 외부 시스템으로부터 전달 받은 정보를 도메인 계층으로 전달하는 경우에도 사용
- DTO는 사용하기 안전하고, 외부 계층의 코드로 부터 보호해주나, 이를 따로 만들어 줘야하고 매번 변환해줘야하는 번거로움이 있다. → AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다.

9-22 도메인 계층 방식 p815

![https://user-images.githubusercontent.com/34182908/196029680-0129b73b-500c-4c7d-9e7e-f1bcc196db1e.png](https://user-images.githubusercontent.com/34182908/196029680-0129b73b-500c-4c7d-9e7e-f1bcc196db1e.png)

- 도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할을 담당하나 특성이 확연히 다름
    - 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복(생명주기가 짧다)
    - 사용자별 요청에 대해 독립적인 상태를 유지해야하기 때문에 싱글톤이 될 수가 없다
    - DAO, 컨트롤러, 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많으므로 빈으로 등록x
    - 특별한 방법으로 DI 해줘야만 다른 3계층의 빈들과 협력해서 일을 처리할 수 있다.
- 이런 제약과 불편을 감수해서라도 이 방식을 택해야 하는 경우(우 복잡하고 변경이 잦은 도메인을 가졌을 때)
    - 도메인 모델과 설계에 변경이 발생시 도메인 계층의 오브젝트도 빠르게 대응해서 변경 가능
    - 도메인 계층의 응집도가 매우 높기 때문에 단위 테스트 작성이 편리(DAO나 외부 서비스 오브젝트와 연동시 도메인 오브젝트 타입을 유지하기 때문에 목 오브젝트 등을 이용해 단위 테스트로 만들기 쉽다)
    - 객체지향적인 설계의 모든 장점을 동원해서 가장 유연한 방법으로 대응 가능

## DTO와 리포트 쿼리

- DTO의 사용이 필요할 때
- 리포트 쿼리(Report query)라 불리는 DB 쿼리 실행 결과를 담는 경우
    - 리포트 쿼리 : 리포트를 출력하기 위해 생성하는 쿼리(종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결과를 생성하는 쿼리)
    - DB 테이블에 담긴 필드의 내용보다는 그 합계, 평균과 같은 계산 값, 여러 테이블의 필드를 다양한 방식으로 조합해서 만듬

# 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

## 계층형 아키텍처

- 3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조
    - 하나의 계층이 다시 수평으로 세분화되거나, 3계층에서 두 개의 계층이 통합돼서 하나의 오브젝트에 담기는 일도 가능
- 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용(SrpingMVC)
- MVC 패턴 지원
- SOFEA(Service Oriented Front End Architecture) : 프리젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드돼서 클라이언트 장치 안에서 동작하면서 서버에 존재하는 서비스 계층 또는 프레젠테이션 계층과 통신하는 구조

![https://user-images.githubusercontent.com/34182908/196029689-50964eb9-6af1-4248-b23c-00bc540361b5.png](https://user-images.githubusercontent.com/34182908/196029689-50964eb9-6af1-4248-b23c-00bc540361b5.png)

9-23 SOFEA

## 정보 전송 아키텍처

- 스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼수 있는 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식
- 도메인 오브젝트를 사용해 애플리케이션의 정보를 인관된 형태로 유지하는게 스프링에 가장 잘 들어맞는 방식
- DB와 SQL에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환시, 데이터 중심의 아키텍처

## 상태 관리와 빈 스코프

- 아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리
- 크게는 사용자 로그인 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보가 있다.
- 하나의 애플리케이션은 수많은 사용자의 요청 처리르 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작 → 서버 자원 특정 사용자에게 일정하게 할당x → 지속적으로 유지되는 상태를 갖지 않는(stateless) 특징을 가짐
- 애플리케이션의 상태, 장시간 진행되는 작업정보는 유지돼야 한다. 이를 위해서 웹 클라이언트에 URL, 파라미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값등을 전달해야한다. 클라이언트와 서버사이에 많은 정보를 계속해서 주고받을 수 없으므로, 중요 상태정보는 파일 시스템, 데이터그리드, DB 등에 저장되기도 한다.(HTTP 세션 같은 서블릿 컨테이너가 제공하는 저장공간을 활용하기도 한다)

- 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장
    - 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문
    - 서버를 여러 대로 확장하기가 매우 쉽다
- 
- 웹 클라이언트에 폼 정보를 출력, 이를 수정하는 등의 작업을 위해서는 HTTP 세션을 적극 활용

- 장기간 유지되면 중찹될 수 있는 상태를 다루느 고급 상태 관리 기법을 이용할 수도 있다,

## 서드파티 프레임워크, 라이브러리 적용

- 스프링이 지원하는 기술의 의미
1. 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다.
2. 스프링의 서비스 추상화가 적용됐다.
3. 스프링이 지지하는 프로그래밍 모델을 적용했다.
4. 템플릿/콜백이 지원된다.
