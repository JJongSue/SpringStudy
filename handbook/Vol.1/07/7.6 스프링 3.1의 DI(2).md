# 7.6 스프링 3.1의 DI

### 전용 태그 전환
- XML에 남아있는 두 개의 빈 설정도 자바 클래스로 옮겨보자
``` 
<jdbc:embedded-database id="embeddedDatabase" type="HSQL">
    <jdbc:script location="classpath:springboot/user/sqlservice/updatable/sqlRegistrySchema.sql" />
</jdbc:embedded-database>

<tx:annotation-driven/>
```

- 남아있는 두가지 모두 Bean이 아니라 특별한 용도로 사용하도록 만들어진 전용 태그다.
  - 내부에서 실제로 어떤 빈이 만들어지는지 파악하기 쉽지 않다.

- 내장형 DB에 대한 테스트를 작성할 때 Builder를 이용해서 EmbeddedDatabase를 생성하고 초기화한 뒤에 DataSource를 리턴받았다.
- Builder가 하는 작업은 `<jdbc:embedded-database>` 태그가 내부적으로 해주는 작업과 거의 동일하다.

```java
@Bean
public DataSource embeddedDatabase(){
    return new EmbeddedDatabaseBuilder()
    .setName("embeddedDatabase")
    .setType("HSQL")
    .addScript("classpath:springboot/user/sqlservice/updatable/sqlRegistrySchema.sql")
    .build();
}
```

- @Bean 메소드로 전환하였으니 @Resource로 빈을 가져올필요가 없다. 
  - @Resource로 정의한 필드를 제거하고, embeddedDatabase() 메소드를 호출해서 빈을 가져오도록 수정한다.

```java
@Bean
public SqlRegistry sqlRegistry(){
    EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
    sqlRegistry.setDataSource(embeddedDatabase());
    return sqlRegistry;
}
```

- 마지막으로 남은 `<tx:annotation-driven/>` 는 AOP를 위해 기본적으로 네 가지 클래스를 빈으로 등록한다.
  > - InfrastructureAdvisorAutoProxyCreator
  > - AnnotationTransactionAttributeSource
  > - TransactionInterceptor
  > - BeanFactoryTransactionAttributeSourceAdvisor

  - 이 네 개의 클래스를 빈으로 등록하고 프로터티를 넣어줄 수 있다면, tx 태그를 대체할 수 있다.
  - 하지만 설정도 어렵고 로우 레벨의 클래스를 여러개나 사용해서 빈을 정의하는 것은 부담스럽다.

- 스프링 3.0은 이런 이유로 XML을 완전히 배제하기 힘들었지만, 3.1에서는 가능하다.
  - `<tx:annotation-driven/>` 처럼 로우 레벨의 빈을 등록하는 전용태그를 대체할 수 있는 애노테이션을 제공한다.
  - @EnableTransactionManagement를 Context 클래스에 붙여주는 것으로 간단히 변환할 수 있다.
  - @Enable로 시작하는 애노테이션은 XML에서 자주 쓰이는 전용 태그들을 대체하는 기능이다.

``` java
@Configuration
@EnableTransactionManagement
public class TestApplicationContext{
 
 
    //db 연결과 트랜젝션 
 
    @Bean 
    public DataSource dataSource(){
        SimpleDriverDataSource db = new SimpleDriverDataSource();
        ds.setDriverClass(Driver.class);
        ds.setUrl("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8");
        ds.setUsername("spring");
        ds.setPassword("book");
        return ds;
    }
 
    @Bean 
    public PlatformTransactionManager transactionManager(){
        DataSourceTransactionManager tm = new DataSourceTransactionManager();
        tm.setDataSource(dataSource());
        return tm;
    }
 
 
    //애플리케이션 로직 & 테스트
 
    @Autowired SqlService sqlService;
 
    @Bean 
    public UserDao userDao(){
        UserDaoJdbc dao = new UserDaoJdbc();
        dao.setDataSource(dataSource());
        dao.setSqlService(this.sqlService);
        return service;        
    }
 
    @Bean 
    public UserService userService(){
        UserServiceImpl service = new UserServiceImpl();
        service.setUserDao(userDao());
        service.setMailSender(mailSender());
        return service;
    }
 
    @Bean 
    public UserService testUserService(){
        testUserService testService = new testUserService();
        testService.setUserDao(userDao());
        testService.setMailSender(mailSender());
        return testService;
    }
       
    @Bean
    public MailSender mailSender(){
        return new DummyMailSender();
    }
 

    // SQL 서비스

    @Bean
    public SqlService sqlService(){
        OxmSqlService sqlService = new OxmSqlService();
        sqlService.setUnmarshaller(unmarshaller());
        sqlService.setSqlRegistry(sqlRegistry());
        return sqlService;
    }
 
    @Bean 
    public SqlRegistry sqlRegistry(){
        EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
        sqlRegistry.setDataSource(embeddedDatabase());
        return sqlRegistry;
    }
 
    @Bean
    public Unmarshaller unmarshaller(){
        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
        marshaller.setContextPath("springbook.user.sqlservice.jaxb");
        return marshaller;
    }
 
    @Bean
    public DataSource embeddedDatabase(){
        return new EnbeddedDatabaseBuilder()
            .setName("embeddedDatabase")
            .setType(HSQL)
            .addScript("classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql")
            .build();
    }
 
}

```

## 7.6.2 빈 스캐닝과 자동 와이어링
### Autowired를 이용한 자동 와이어링

- XML의 빈 설정정보를 클래스와 메소드로 변환했다. 
- 빈의 프로퍼티에 다른 빈을 넣어 런타임 관계를 맺어주려면 <bean>의 <property>를 사용하거나, 자바 코드로 수정자 메소드를 직접 호출해줘야 했다.

``` java
@Bean 
public UserDao userDao(){
    UserDaoJdbc dao = new UserDaoJdbc();
    dao.setDataSource(dataSource());
    dao.setSqlService(this.sqlService);
    return service;        
}
```

- UserDaoJdbc 같은 클래스에도 @Autowired를 사용할 수 있다. 
- 현재 UserDaoJdbc는 dataSource와 sqlService에 의존하고 있으므로 userDao() 메소드에서는 위와 같이 수정자 메소드를 통해 두 개의 빈 오브젝트를 직접 주입하고 있다.
  - 이 중 dataSource 빈을 넣어주는 위의 수정자 메소드를 자동와이어링(@Autowired)를 사용하여 제거해보자.

``` java
public class UserDaoJdbc implements UserDao{

    @Autowired
    public void setDataSource(DataSource dataSource){
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
} 
```

- 스프링은 @Autowired가 붙은 수정자 메소드가 있으면 파라미터 타입(여기서는 DataSource)을 보고 주입 가능한 타입의 빈을 모두 찾아온다. 
- 타입에 해당하는 빈이 하나면 바로 주입하고, 두 개 이상이 나오면 프로퍼티와 동일한 이름의 빈이 있는지 찾는다.
  - 예제에서 DataSource 타입의 빈은 userDao가 사용하는 dataSource와 SQL 서비스용으로 만든 embeddedDatbase 빈이 존재한다.
  - 이 중 프로퍼티와 이름이 동일한 dataSource 빈이 주입된다.

- 마찬가지로 sqlService 프로퍼티에도 @Autowired를 적용한다.
``` java
public class UserDaoJdbc implements UserDao{
    
    @Autowired
    public void setDataSource(DataSource dataSource){
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Autowired
    private SqlService sqlService;

    public void setSqlService(SqlService sqlService){
        this.sqlService = sqlService;
    }
} 
``` 

``` java
@Bean
public UserDao userDao(){
    //프로퍼티 메소드 삭제
    return new UserDaoJdbc();
}
```

- sqlService는 UserDaoJdbc 클래스에서 dataSource 빈과 달리 수정자가 아닌 필드에 직접 주입했다.
  - 필드의 접근제어자가 private이어도 스프링은 리플렉션 API를 이용해 우회해서 값을 주입한다.
- dataSource 빈은 jdbcTemplate을 생성해서 저장하는 작업이 필요하므로 필드에 주입하는 방식은 적용할 수 없다.

### Component를 이용한 자동 빈 등록
- @Component는 클래스에 부여되어 @Component 또는 @Component를 메타 애노테이션으로 갖고 있는 클래스는 자동 빈 등록 대상이 된다.
- 이번에는 userDao() 메소드를 아예 제거해보자.
  - @Autowired를 이용한다.

  ``` java
  @Autowired UserDao userDao;

    @Bean 
    public UserService userService(){
        UserServiceImpl service = new UserServiceImpl();
        service.setUserDao(this.userDao);
        service.setMailSender(mailSender());
        return service;
    }
 
    @Bean 
    public UserService testUserService(){
        testUserService testService = new testUserService();
        testService.setUserDao(this.userDao);
        testService.setMailSender(mailSender());
        return testService;
    }
  ```

  - 이후 자동 빈 등록 대상이 될 UserDaoJdbc 클래스에 @Component 애노테이션을 넣는다.
  ```java
  @Component
  public class UserDaoJdbc implements UserDao{ ... }
  ```
  
  - Component 애노테이션이 달린 클래스를 자동으로 찾아 빈으로 등록하려면 빈 스캔 기능을 사용하겠다는 애노테이션 정의가 필요하다.
  - DI 설정용 클래스에 @ComponentScan을 사용하여 @Component가 붙은 클래스들을 스캔한다.
    - @ComponentScan의 basePackages 엘리먼트는 스캔을 시작할 기준 패키지를 지정한다.
    - @Component가 붙은 클래스는 빈으로 등록될 때 빈의 아이디는 첫 글자를 소문자로 바꿔서 사용한다(UserDaoJdbc -> userDaoJdbc)
    - @Component로 등록하는 경우 빈의 Id가 userDao에서 userDaoJdbc로 변경된다. 
      - 하지만 이 빈을 참조하는 UserServiceTest나 TestApplicationContext는 @Autowired를 이용해 빈을 주입받으므로 상관없다.

- 빈 자동등록에 @Component 애노테이션 뿐만아니라 @Component 애노테이션을 메타 애노테이션으로 갖고있는 애노테이션도 사용할 수 있다.
  - 메타 애노테이션은 애노테이션의 정의에 부여된 애노테이션을 말한다.
  - @SnsConnector 애노테이션을 정의할 때 메타 애노테이션으로 @Component를 부여하면 클래스마다 @Component를 따로 붙여주지 않아도 자동 빈 등록 대상으로 만들 수 있다.
  ``` java
  @Component 
  public @interface SnsConnector{ ... }
  ```
  ``` java
  @SnsConnector
  public class FacebookConnector{ ... }
  ```

- UserDaoJdbc는 데이터 액세스 서비스를 제공하는 DAO 빈이다. 스프링은 이런 DAO 빈을 자동 등록할 때 사용할 수 있는 @Repository 애노테이션을 제공한다. 
  - 마찬가지로 @Component를 메타 애노테이션으로 갖고 있다.
  ``` java
  @Repository
  public class UserDaoJdbc implements UserDao{ ... }
  ```  

- UserService 빈에도 자동 와이어링과 자동 빈 등록을 적용한다.
``` java
@Component
public class UserServiceImpl impliments UserService{
    ...

    @Autowired
    private UserDao userDao;

    @Autowired
    private MailSender mailSender;
}
```
- 자동 등록하였으니 TestApplicationContext에서 userService() 메소드를 삭제하자. 
  - 하지만 UserService 타입의 빈은 현재 두 개가 존재하므로, 빈 아이디를 userService라고 명시해준다.
    - userServiceImpl, testUserService가 존재하며 둘의 타입은 UserService로 동일하다. 따라서 @Autowired에서 타입으로 빈을 조회 시 둘 다 조회됨.  
  - 또, 비즈니스 로직을 담고 있는 서비스 계층의 빈을 구분하기 위해 @Component보다 @Service 애노테이션을 사용하자.  
  ``` java
  @Service("userService")
  public class UserServiceImpl implements UserService{ ... }
  ```  


- dataSource 빈과 transactionManager 빈은 자동등록 기능을 사용하고 싶어도 불가능하다.
  - 스프링이 제공해준 클래스를 사용하므로 소스코드에 @Component, @Autowired를 적용할 수 없다.

## 7.6.3 컨텍스트 분리와 @Import

- 현재 애플리케이션이 동작하는 데 필요한 DI 정보와 테스트를 위해 만든 DI 정보가 하나의 파일 안에 혼재해 있다.
- 성격이 다른 DI 정보를 분리하자

### 테스트용 컨텍스트 분리
- testUserService, mailSender(더미) 빈은 테스트에서나 필요하지 운영 중에 사용되면 안된다.
- TestAppContext라는 DI 설정 클래스를 추가하고 @Configuration으로 설정 정보 파일임을 명시한다.
``` java
@Configuration
public class TestAppContext{
    @Autowired UserDao userDao;

    // @Bean
    // public UserService testUserService(){
    //     testUserService testService = new testUserService();
    //     testService.setUserDao(this.userDao);
    //     testService.setMailSender(mailSender());
    //     return testService;
    // }

    // 자동 와이어링으로 간략하게 변경한다.
    @Bean
    public UserService testUserService(){
        return new TestUserService();
    }

    @Bean
    public MailSender mailSender(){
        return new DummyMailSender();
    }
}
```  
- 두 개의 설정 클래스를 사용해야 하므로 테스트에서 두 개의 DI 클래스를 사용하도록 변경한다.
``` java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes={TestAppContext.class, AppContext.class})
```

### @Import
- AppContext에는 테스트 전용 빈 정보가 사라졌으나 아직 SQL 서비스용 빈이 남아있다.
- SQL 서비스는 그 자체로 독립적인 모듈처럼 취급하는게 낫다.
  - 다른 애플리케이션에서도 사용될 수 있다
  - 독립적으로 개발되거나 변경될 가능성이 높다.
  - DAO는 SqlService 타입의 빈만 DI 받으면 된다. 구체적인 구현 방법에는 관심이 없다.

- 테스트 전용 빈들을 분리할 때처럼 SqlServiceContext라는 @Configuration 클래스를 하나 더 생성한다.
``` java
@Configuration
public class SqlServiceContext{
    @Bean
    public SqlService sqlService(){
        OxmSqlService sqlService = new OxmSqlService();
        sqlService.setUnmarshaller(unmarshaller());
        sqlService.setSqlRegistry(sqlRegistry());
        return sqlService;
    }
 
    @Bean 
    public SqlRegistry sqlRegistry(){
        EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
        sqlRegistry.setDataSource(embeddedDatabase());
        return sqlRegistry;
    }
 
    @Bean
    public Unmarshaller unmarshaller(){
        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
        marshaller.setContextPath("springbook.user.sqlservice.jaxb");
        return marshaller;
    }
 
    @Bean
    public DataSource embeddedDatabase(){
        return new EnbeddedDatabaseBuilder()
            .setName("embeddedDatabase")
            .setType(HSQL)
            .addScript("classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql")
            .build();
    }
}
```

- SQL 서비스와 관련된 빈은 테스트용 설정정보와 달리 애플리케이션이 동작할 때 항상 필요한 정보다.
  - 별도 클래스로 분리하긴 했지만 AppContext와 긴밀하게 연결해주는 것이 좋다.
  - AppContext가 메인 설정정보가 되고 SqlServiceContext는 보조 설정정보로 사용하도록 @Import를 이용한다.
  ``` java 
  @Configuration
  @EnableTransactionManagement
  @ComponentScan(basePackages="springbook.user")
  @Import(SqlServiceContext.class)
  public class AppContext{ ... }
  ```