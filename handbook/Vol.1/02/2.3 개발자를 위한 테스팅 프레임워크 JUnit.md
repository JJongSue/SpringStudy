# 2장 - 테스트

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit
> 스프링 프레임워크 자체도 JUnit 프레임워크를 이용해 테스트를 만들어가며 개발됐음.  
> 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.  
> 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### 2.3.1 JUnit 테스트 실행 방법  
* JUnitCore를 이용해 테스트를 실행하고 콘솔에 출력된 메세지를 보고 결과를 확인하는 방법은 가장 간단함.
  * 하지만 테스트의 수가 많아지면 관리하기가 힘들어지는 단점이 있음.

```java
public static void main(String[] args) {
  JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```
* 가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원도구를 사용하는 것이다.
  * JUnitCore를 이용할 때처럼 main() 메소드를 만들지 않아도 된다.

### IDE  
* @TEST 가 들어 있는 테스트 클래스를 선택한 뒤에, 이클립스 메뉴 run - Run As - JUnit Test 를 선택하면 테스트가 자동으로 실행된다.  
* 테스트가 시작되면 JUnit 테스트 정보를 표시해주는 뷰가 나타나고 테스트 진행상황을 보여줌
  * 테스트 총 수행시간
  * 실행한 테스트의 수
  * 테스트 에러의 수
  * 테스트 실패의 수
  * 어떤 테스트 클래스를 실행했는지도 알 수 있음
* 테스트가 실패해서 코드를 수정한 뒤, 다시 테스트를 실행하려면 JUnit 테스트 뷰의 Rerun Test 버튼을 클린하면 된다.
  * 테스트 실패한 이유는 뷰의 아래 Failure Trace 항목에 자세히 나와있음
* JUnit은 한번에 여러 테스트 클래스를 동시에 실행할 수 있음
  * 특정 패키지 또는 소스 폴더나 프로젝트 전체를 선택하고 run - Run As - JUnit Test 실행한다.
* JUnit 테스트 실행 단축키 : Alt + Shift + X + T

### 빌드 툴
* 프로젝트 빌드를 위해 ANT나 메이븐 같은 빌드 툴과 스크립트를 사용하고 있다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있음.
* 개발자 개인별로는 IDE에서 JUnit 도구를 활용해 테스트를 실행하는게 가장 편리함
  * 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 하는 경우 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋음
  * 이 때 빌드 스크립트를 이용해 JUnit 테스트를 실행한다.

### 2.3.2 테스트 결과의 일관성
* 지금까지 JUnit 테스트를 실행하면서 불편한 점은 DB User 테이블의 해당 데이터를 삭제해줘야 하는 일이었다.
  * 사용자의 기본키가 중복되면서 add() 실행 에러가 나기 때문이다.
* 지금 발생하는 문제는 별도의 준비 작업 없이는 성공해야 마땅한 테스트가 실패하기도 한다는 점이다.
* 반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없음.
  * 코드의 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.
* 가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어 주는 것이다.

#### UserDao.java deleteAll() 추가
```java
public void deleteAll() throws SQLException {
 Connection c = dataSource.getConnection();

 PreparedStatement ps = c.prepareStatement("delete from users");
 ps.executeUpdate();

 ps.close();
 c.close();
}	
```

#### UserDao.java - getCount() 추가
```java
public int getCount() throws SQLException  {
 Connection c = dataSource.getConnection();

 PreparedStatement ps = c.prepareStatement("select count(*) from users");

 ResultSet rs = ps.executeQuery();
 rs.next();
 int count = rs.getInt(1);

 rs.close();
 ps.close();
 c.close();

 return count;
}
```

#### deleteAll()과 getCount()의 테스트
* 새로운 기능을 추가했으니, 추가된 기능에 대한 테스트도 만들어야 함.
* 1️⃣ addAndGet() 메소드 실행 전 deleteAll() 실행
* 2️⃣ deleteAll() 만 사용하는 것은 자체 검증이 안됐으므로 getCount()를 함께 적용한다.
  * deleteAll() 실행 후 기대한대로 동작한다면, getCount() 실행 결과는 0이 나와야 한다.
* 3️⃣ getCount() 의 검증을 위해 add() 를 수행하고 나서 getCount()를 실행하여 1이 나오는지 확인한다.

```java
public class UserDaoTest {
	@Test 
	public void andAndGet() throws SQLException {
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
		UserDao dao = context.getBean("userDao", UserDao.class);
		
		dao.deleteAll();
		assertThat(dao.getCount(), is(0));
		
		User user = new User();
		user.setId("gyumee");
		user.setName("박성철");
		user.setPassword("springno1");

		dao.add(user);
		assertThat(dao.getCount(), is(1));
		
		User user2 = dao.get(user.getId());
		
		assertThat(user2.getName(), is(user.getName()));
		assertThat(user2.getPassword(), is(user.getPassword()));
	}
}
```

#### 동일한 결과를 보장하는 테스트
* 이클립스에서 JUnit 테스트를 실행했다면, JUnit 뷰에 녹색 막대가 나타나면서 테스트 성공했다고 나올 것이다.  

* 동일한 테스트 결과를 얻을 수 있는 다른 방법도 있다
  * addAndGet() 테스트를 마치기 직전에 추가한 데이터를 모두 원래 상태로 만들어주는 것이다.
* 하지만 위 방법은 addAndGet() 테스트 실행 이전에 다른 이유로 USER 테이블에 데이터가 들어가 있다면 테스트가 실패할 수도 있다.
* 따라서 테스트하기 전에 테스트 실행에 문제가 되지 않는 상태를 만들어주는 편이 더 나을 것이다.
#### 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안된다.
#### DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.
</br>

### 2.3.3 포괄적인 테스트
* 두 개 이상의 레코드를 add() 했을 때는 getCount()의 실행결과가 어떻게 될까?
* 0과 1 두 가지를 해봤으니 나머지도 당연히 잘될 것이라고 추정할 수도 있겠지만 미처 생각하지 못한 문제가 숨어 있을지도 모르니 꼼꼼한 테스트를 해보는 것이 좋다.
* 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

#### getCount() 테스트
* 여러 개의 User를 등록해가면서 getCount()의 결과를 매번 확인하는 꼼꼼한 테스트를 만들어보자.
  * 이 테스트의 기능을 기존의 addAndGet() 메소드에 추가하는 건 별로 좋은 생각이 아니다.
  * 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
* JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다.
  * @TEST 가 붙어 있고,
  * public 접근자가 있으며,
  * 리턴 값이 void 형이고,
  * 파라미터가 없다는 조건을 지키기만 하면 된다.
* 테스트 시나리오는 아래와 같다.
  * 1️⃣ USER 테이블의 데이터를 모두 지우고 getCount()로 레코드 개수가 0임을 확인한다.
  * 2️⃣ 3개의 사용자 정보를 하나씩 추가하면서 매번 getCount()의 결과가 하나씩 증가하는지 확인한다.
* 테스트를 만들기 전에 먼저 User 클래스에 한 번에 모든 정보를 넣을 수 있도록 아래와 같이 초기화가 가능한 생성자를 추가한다.  
#### User.java 생성자 추가
```java
public class User {
	String id;
	String name;
	String password;

	public User() {
	}
	
	public User(String id, String name, String password) {
		this.id = id;
		this.name = name;
		this.password = password;
	}
 // 이하 생략
}
```

